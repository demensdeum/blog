Format: Fall24-October10
Language: ru
Title: Не бойся, посмотри как он увеличивается
Slug: itgrows
Categories: blog,techie,tutorials
<p>В данной заметке я расскажу о своих злоключениях с умными указателями shared_ptr. После реализации генерации следующего уровня в своей игре <a href="https://gitlab.com/demensdeum/Death-Mask" target="_blank" rel="noopener">Death-Mask</a>, я заметил утечку памяти. Каждый новый уровень давал прирост + 1 мегабайт к потребляемой оперативной памяти. <strong>Очевидно</strong> что какие-то объекты оставались в памяти и не освобождали ее. Для исправления данного факта необходимо было реализовать корректную реализацию ресурсов при перегрузке уровня, чего видимо сделано не было. Так как я использовал умные указатели, то вариантов решения данной задачи было несколько, первый заключался в ручном отсмотре кода (долго и скучно), второй же предполагал исследование возможностей дебагера lldb, исходного кода libstdc++ на предмет возможности автоматического отслеживания изменений счетчика.</p>
<p>В интернете все советы сводились к тому чтобы вручную отсматривать код, исправить и бить себя плетями после нахождения проблемной строчки кода. Также предлагалось реализовать свою собственную систему работы с памятью, как это делают все крупные проекты разрабатываемые еще с 90-х и нулевых, до прихода умных указателей в стандарт C++11. Мною была предпринята попытка использовать брейкпоинты на конструкторе копии всех shared_ptr, после нескольких дней ничего дельного не получилось. Была идея добавить логирование в библиотеку libstdc++, однако трудозатраты (о)казались чудовищными.</p>
<p><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1412" src="https://demensdeum.com/blog/wp-content/uploads/2018/06/edwardhacking.png" alt="" width="500" height="375" srcset="https://demensdeum.com/blog/wp-content/uploads/2018/06/edwardhacking.png 500w, https://demensdeum.com/blog/wp-content/uploads/2018/06/edwardhacking-300x225.png 300w" sizes="auto, (max-width: 500px) 100vw, 500px" /><br />
Cowboy Bebop (1998)</p>
<p>Решение пришло мне в голову внезапно в виде отслеживания изменений приватной переменной shared_ptr &#8211; use_count. Сделать это можно с помощью встроенных в lldb ватчпоинтов (watchpoint) После создания shared_ptr через make_shared, изменения счетчика в lldb можно отслеживать с помощью строки:<br />
<!-- HTML generated using hilite.me --></p>
<div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">watch <span style="color: #008800; font-weight: bold;">set</span> <span style="color: #008800; font-weight: bold;">var</span> camera._M_refcount._M_pi->_M_use_count
</pre>
</div>
<p>Где &#8220;camera&#8221; это shared_ptr объект состояние счетчика которого необходимо отследить. Конечно внутренности shared_ptr будут различаться в зависимости от версии libstdc++, но общий принцип понять можно. После установки ватчпоинта запускаем приложения и читаем стектрейс каждого изменения счетчика, потом отсматриваем код (sic!) находим проблему и исправляем. В моем случае объекты не освобождались из таблиц-кешэй и таблиц игровой логики. Надеюсь данный метод поможет вам разобраться с утечками при работе с shared_ptr, и полюбить этот инструмент работы с памятью еще больше. Удачного дебага.</p>