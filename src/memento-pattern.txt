Format: Fall24-October10
Language: ru
Title: Паттерн &#8220;Снимок&#8221;
Slug: memento-pattern
Categories: techie,tutorials
<p>В данной заметке я опишу паттерн &#8220;Снимок&#8221; или &#8220;Memento&#8221;</p>
<p>Данный паттерн относится к &#8220;Поведенческим&#8221; шаблонам проектирования.</p>
<h3><a href="https://pxhere.com/en/photo/655263" target="_blank" rel="noopener noreferrer"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-1834" src="https://demensdeum.com/blog/wp-content/uploads/2019/04/hipster-camera-1.jpg-1.jpg" alt="" width="360" height="240" /></a></h3>
<p>Допустим мы разрабатываем графический редактор, и нам нужно добавить возможность откатывать действия по команде пользователя. Также очень важно чтобы у компонентов системы не было доступа к внутреннему состоянию откатываемых &#8220;действий&#8221;, при реализации данного паттерна у других компонентов системы есть доступ только к обьекту-снимку без возможности менять его внутреннее состояние, с предоставлением понятного, простого внешнего интерфейса . Для решения данной задачи используется паттерн &#8220;Снимок&#8221; или &#8220;Хранитель&#8221;.</p>
<p>Пример работы &#8220;Снимка&#8221; представлен ниже:</p>

<!-- iframe plugin v.5.1 wordpress.org/plugins/iframe/ -->
<iframe loading="lazy" src="https://demensdeum.com/demos/memento/index.html" width="400" height="600" scrolling="yes" class="iframe-class" frameborder="0"></iframe>

<p>При нажатии появляется спрайт, при нажатии на закрученную стрелку действие отменяется &#8211; спрайт исчезает. Пример состоит из трех классов:</p>
<ol>
<li>Канва (canvas) на котором отображаются спрайты, графический интерфейс.</li>
<li>Контроллер экрана, он обрабатывает нажатия и управляет логикой экрана.</li>
<li>Состояния канвы которые сохраняются при каждом изменении, откатываются при необходимости с помощью контроллера экрана.</li>
</ol>
<p>В разрезе паттерна &#8220;Снимок&#8221; классы представляют из себя:</p>
<ol>
<li>Канва &#8211; источник, состояния этого класса сохраняются как &#8220;снимки&#8221;, для последующего отката по запросу. Также источник обязан уметь восстанавливать состояние при передаче ему &#8220;снимка&#8221;.</li>
<li>Контроллер &#8211; хранитель, этот класс знает как и когда сохранять/откатывать состояния.</li>
<li>Состояние &#8211; снимок, класс который хранит состояние источника, плюс информацию о дате или индекс, по которому можно точно установить порядок для отката.</li>
</ol>
<p>Важная особенность паттерна состоит в том, что иметь доступ к внутренним полям сохраненного состояния в снимке должен только источник, это необходимо для защиты снимков от изменений из вне (от рукастых разработчиков, желающих что-то поменять в обход инкапсуляции, ломающих логику системы). Для реализации инкапсуляции используют встраиваемые классы, а в C++ применяют возможность задания friend классов. Лично я реализовал простую версию без инкапсуляции для Rise, и с использованием Generic при реализации для Swift. В моем варианте &#8211; Memento отдает свой внутренний стейт только сущностям одного со стейтом класса:<br />
<img loading="lazy" decoding="async" class="alignnone size-full wp-image-1856" src="https://demensdeum.com/blog/wp-content/uploads/2019/04/stateByRequest.jpg" alt="" width="321" height="203" /></p>
<h3>Источники</h3>
<p><a href="https://refactoring.guru/design-patterns/memento" target="_blank" rel="noopener noreferrer">https://refactoring.guru/design-patterns/memento</a></p>
<h3>Исходный код</h3>
<p><a href="https://gitlab.com/demensdeum/patterns/" target="_blank" rel="noopener noreferrer">https://gitlab.com/demensdeum/patterns/</a></p>