Format: Fall24-October10
Language: ru
Title: Двоичный поиск
Slug: binary-search
Categories: techie,tutorials
<p>Допустим нам необходимо узнать относится ли адрес электронной почты “<a href="mailto:demensdeum@gmail.com">demensdeum@gmail.com</a>”  к списку разрешенных email адресов для получения писем.</p>
<p>Переберем весь список от первого до последнего элемента, проверяя равен ли элемент указанному адресу &#8211; реализуем алгоритм линейного поиска. Но это же будет долго, или не будет?</p>
<p>Для ответа на этот вопрос используют “Временную сложность алгоритмов”, “О” нотацию. Время работы линейного поиска в худшем случае равно n-му количеству элементов массива, напишем это в “О” нотации &#8211; O(n). Далее нужно пояснить что для любого известного алгоритма есть три показателя производительности &#8211; время выполнения в лучшем, худшем и среднем случае. Например адрес почты “<a href="mailto:demensdeum@gmail.com">demensdeum@gmail.com</a>” находится в первом индексе массива, тогда он будет найден за первый шаг алгоритма, из этого следует что время выполнения в лучшем случае &#8211; O(1); а если в конце списка, то это худший случай &#8211; O(n)</p>
<p><a href="http://www.peakpx.com/485573/yellow-and-black-road-sign" target="_blank" rel="noopener"><img loading="lazy" decoding="async" class="alignnone size-full wp-image-2387" src="https://demensdeum.com/blog/wp-content/uploads/2019/12/roadSign-1.jpg" alt="" width="320" height="240" srcset="https://demensdeum.com/blog/wp-content/uploads/2019/12/roadSign-1.jpg 320w, https://demensdeum.com/blog/wp-content/uploads/2019/12/roadSign-1-300x225.jpg 300w" sizes="auto, (max-width: 320px) 100vw, 320px" /></a></p>
<p>Но как же детали реализации ПО, производительность железа, они ведь должны влиять на big O? А теперь выдохните и представьте что расчет временной сложности рассчитывается для некой абстрактной идеальной машины, в которой есть только этот алгоритм и больше ничего.</p>
<h3>Алгоритм</h3>
<p>Ок, получается что линейный поиск достаточно медленный, попробуем использовать Бинарный поиск. Для начала следует пояснить что с бинарными данными мы работать не будем, такое название данному методу дано из-за особенностей его работы. Изначально мы сортируем массив в <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA" target="_blank" rel="noopener">лексикографическом порядке</a>, затем алгоритм берет диапазон всего массива, получает средний элемент диапазона, сравнивает его <a href="https://ru.stackoverflow.com/questions/489888/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%87%D1%82%D0%BE-%D0%BE%D0%BD%D0%BE-%D1%81%D0%BE%D0%B1%D0%BE%D0%B9-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82" target="_blank" rel="noopener">лексикографически</a>, и в зависимости от результата сравнения решает какой диапазон брать для поиска дальше &#8211; верхнюю половину текущего или нижнюю. То есть на каждом шаге поиска принимается решение из двух возможных &#8211; бинарная логика. Этот шаг повторяется до тех пор, пока либо слово найдется, либо не найдется (произойдет пересечение нижнего и верхних индексов диапазона).</p>
<p>Производительность данного алгоритма &#8211; лучший случай когда сразу найден элемент в середине массива O(1), худший случай перебора O(log n)</p>
<h3>Подводные камни</h3>
<p>При реализации бинарного поиска я встретился мало того с интересной проблемой <b>отсутствия стандартизации лексикографического сравнения</b> в библиотеках языков программирования, но даже обнаружил отсутствие <b>единого стандарта реализации localeCompare внутри JavaScript</b>. Стандарт ECMAScript допускает разную реализацию данной функции, из-за этого при сортировке с помощью localeCompare, на разных движках JavaScript может наблюдаться абсолютно разный результат.</p>
<p>Поэтому для корректной работы алгоритма нужно обязательно <b>сортировать и использовать в работе только один и тот же</b> алгоритм лексикографического сравнения, иначе работать ничего не будет. Со-но если например попытаться сортировать массив в Scala, а искать с помощью nodejs, не реализуя собственную сортировку/сортировку одной реализации, то кроме разочарования в человечестве вас ничего не ждет.</p>
<h3>Источники</h3>
<p><a href="https://ru.stackoverflow.com/questions/489888/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BB%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%87%D1%82%D0%BE-%D0%BE%D0%BD%D0%BE-%D1%81%D0%BE%D0%B1%D0%BE%D0%B9-%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82" target="_blank" rel="noopener">Что такое лексикографическое сравнение и что оно собой представляет?</a><br />
<a href="https://ru.stackoverflow.com/questions/794557/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B4%D0%BB%D1%8F-%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%D1%81%D1%8F-log-n-%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BE-lb-n" target="_blank" rel="noopener">Почему для вычисления сложности алгоритмов используется log N вместо lb N?</a><br />
<a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA" target="_blank" rel="noopener">Двоичный поиск</a><br />
<a href="https://habr.com/ru/post/188010/" target="_blank" rel="noopener">Знай сложности алгоритмов</a><br />
<a href="https://stackoverflow.com/questions/52941016/sorting-in-localecompare-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/52941016/sorting-in-localecompare-in-javascript</a></p>
<h3>Исходный код</h3>
<p><a href="https://gitlab.com/demensdeum/algorithms" target="_blank" rel="noopener">https://gitlab.com/demensdeum/algorithms</a></p>