Format: Fall24-October10
Language: ru
Title: Блок-схемы на практике без формалина
Slug: block-schemes-in-practice
Categories: techie,tutorials
Блок-схемы — это наглядный инструмент, который помогает превратить сложный алгоритм в понятную и структурированную последовательность действий. От программирования до управления бизнес-процессами, они служат универсальным языком для визуализации, анализа и оптимизации самых сложных систем.

Представьте себе карту, где вместо дорог — логика, а вместо городов — действия. Это и есть блок-схема — незаменимый инструмент для навигации по самым запутанным процессам.

Пример 1: Упрощённая схема запуска игры
Чтобы понять принцип работы, давайте представим простую схему запуска игры.
<code>
@startuml
start
:Пользователь запускает игру мышью;
:Игра запущена;
stop
@enduml
</code>
Эта схема показывает идеальный сценарий, когда всё происходит без сбоев. Но в реальной жизни всё гораздо сложнее.

Пример 2: Расширенная схема запуска игры с загрузкой данных
Современные игры часто требуют подключения к интернету для загрузки данных пользователя, сохранений или настроек. Давайте добавим эти шаги в нашу схему.

<code>
@startuml
start
:Пользователь запускает игру мышью;
:Подключение к серверу;
:Загрузка данных пользователя;
:Инициализация игрового мира;
:Игра запущена;
stop
@enduml
</code>

Эта схема уже более реалистична, но что произойдёт, если что-то пойдёт не так?

<h2>Как было: Игра, которая "ломалась" при потере интернета<h2>

На старте проекта разработчики могли не учесть всех возможных сценариев. Например, они сосредоточились на основной логике игры и не подумали, что произойдет, если у игрока пропадет интернет-соединение.

В такой ситуации блок-схема их кода выглядела бы так:

<code>
```uml
@startuml
start
:Пользователь запускает игру;
:Подключение к серверу;
:Запрос данных пользователя;
if (Есть интернет-соединение?) then (да)
  :Загрузка данных пользователя;
  :Инициализация игрового мира;
  :Игра запущена;
else (нет)
  :Ошибка: Нет ответа от сервера;
  :Программа не может продолжить;
  :Зависание приложения (черный экран);
endif
stop
@enduml
```
</code>

В этом случае, вместо того чтобы выдать ошибку или корректно закрыться, игра замирала на этапе ожидания данных, которых не получала из-за отсутствия соединения. Это приводило к "чёрному экрану" и зависанию приложения.

### Как стало: Исправление по жалобам пользователей

После многочисленных жалоб пользователей на зависания, команда разработчиков поняла, что нужно исправить ошибку. Они внесли изменения в код, добавив блок обработки ошибки, который позволяет приложению корректно реагировать на отсутствие соединения.

Вот как выглядит исправленная блок-схема, где учтены оба сценария:

<code>
```uml
@startuml
start
:Пользователь запускает игру;
:Подключение к серверу;
:Запрос данных пользователя;
if (Есть интернет-соединение?) then (да)
  :Загрузка данных пользователя;
  :Инициализация игрового мира;
  :Игра запущена;
else (нет)
  :Вывод ошибки "Нет соединения с сервером";
  :Переход в офлайн-режим (если предусмотрен);
  :Завершение сеанса;
endif
stop
@enduml
```
</code>

Благодаря такому подходу, игра теперь корректно информирует пользователя о проблеме, а в некоторых случаях даже может перейти в офлайн-режим, позволяя продолжить игру. Это наглядный пример того, почему **блок-схемы так важны**: они заставляют разработчика думать не только об идеальном пути выполнения, но и о всех возможных сбоях, делая итоговый продукт гораздо более стабильным и надёжным.

<h2>Неопределенное поведение</h2>

Зависания и ошибки — это лишь один из примеров непредсказуемого поведения программы. В программировании существует понятие **неопределённого поведения (Undefined Behavior)** — это ситуация, когда стандарт языка не описывает, как должна вести себя программа в определённом случае.

Это может привести к чему угодно: от случайного "мусора" в выводе до сбоя программы или даже серьёзной уязвимости безопасности. Неопределённое поведение часто возникает при работе с памятью, например, со строками в языке C.

Пример из языка C:

Представьте, что разработчик скопировал строку в буфер, но забыл добавить в конец **нулевой символ (`\0`)**, который отмечает конец строки.

Вот как выглядит код:

<code>
#include <stdio.h>
#include <string.h>

int main() {
char buffer\[5];
char* my_string = "hello";

memcpy(buffer, my_string, 5);

printf("%s\n", buffer);
return 0;
}
</code>

<b>Ожидаемый результат:</b> "hello"
<b>Реальный результат</b> Непредсказуем.

Почему так происходит? Функция `printf` с спецификатором `%s` ожидает, что строка завершается нулевым символом. Если его нет, она продолжит читать память за пределами выделенного буфера.

Вот блок-схема этого процесса с двумя возможными исходами:

<code>
```uml
@startuml
start
:Выделение памяти для 'buffer' (5 байт);
:Копирование 5 символов "hello" в 'buffer';
if (Случайно обнаружен 0 в памяти после 'buffer'?) then (да)
:Функция printf() выводит символы до 0;
:Возможный вывод: "hello" + случайные символы до 0;
else (нет)
:Функция printf() продолжает чтение за пределами 'buffer';
:Неопределенное поведение (Undefined Behavior):;
:Возможные результаты: крах программы, вывод мусора, зависание и т.д.;
endif
stop
@enduml
```
</code>

Это наглядный пример того, почему блок-схемы так важны: они заставляют разработчика думать не только об идеальном пути выполнения, но и о всех возможных сбоях, включая такие низкоуровневые проблемы, делая итоговый продукт гораздо более стабильным и надёжным.
