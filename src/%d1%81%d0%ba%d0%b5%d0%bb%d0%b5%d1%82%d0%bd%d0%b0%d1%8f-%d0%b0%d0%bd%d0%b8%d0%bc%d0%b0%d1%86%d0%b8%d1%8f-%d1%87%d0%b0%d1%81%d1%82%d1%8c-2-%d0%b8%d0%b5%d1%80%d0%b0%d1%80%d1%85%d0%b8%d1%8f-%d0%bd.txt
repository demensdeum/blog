Format: Fall24-October10
Language: ru
Title: Скелетная анимация (Часть 2 &#8211; иерархия нод, интерполяция)
Slug: %d1%81%d0%ba%d0%b5%d0%bb%d0%b5%d1%82%d0%bd%d0%b0%d1%8f-%d0%b0%d0%bd%d0%b8%d0%bc%d0%b0%d1%86%d0%b8%d1%8f-%d1%87%d0%b0%d1%81%d1%82%d1%8c-2-%d0%b8%d0%b5%d1%80%d0%b0%d1%80%d1%85%d0%b8%d1%8f-%d0%bd
Categories: blog,techie,tutorials
<p>Продолжаю описывать алгоритм скелетной анимации, по мере его реализации в игровом движке Flame Steel Engine.</p>
<p><strong><em>Так как алгоритм является наисложнейшим из всех что я реализовывал, в заметках о процессе разработки могут появляться ошибки. В прошлой статье о данном алгоритме я допустил ошибку, массив костей передается в шейдер для каждого мэша по отдельности, а не для всей модели.</em></strong></p>
<h3>Иерархия нод</h3>
<p>Для корректной работы алгоритма необходимо чтобы модель содержала в себе связь костей друг с другом (граф). Представим себе ситуацию при которой проигрываются одновременно две анимации &#8211; прыжок и поднятие правой руки. Анимация прыжка должна поднимать модель по оси Y, при этом анимация поднятия руки должна учитывать это и подниматься вместе с моделью в прыжке, иначе рука останется сама по себе на месте.</p>
<p>Опишем связь нод для данного случая &#8211; тело содержит руку. При отработке алгоритма будет произведено чтение графа костей, все анимации будут учтены с корректными связями. В памяти модели граф хранится отдельно от всех анимаций, только для отражения связанности костей модели.</p>
<h3>Интерполяция на CPU</h3>
<p>В прошлой статья я описал принцип рендеринга скелетной анимации &#8211; “матрицы трансформации передаются из CPU в шейдер при каждом кадре рендеринга.”</p>
<p>Каждый кадр рендеринга обрабатывается на CPU, для каждой кости мэша движок получает финальную матрицу трансформации с помощью интерполяции позиции, поворота, увеличения. Во время интерполяции финальной матрицы кости, производится проход по древу нод для всех активных анимаций нод, финальная матрица перемножается с родительскими, затем отправляется на рендеринг в вертексный шейдер.</p>
<p>Для интерполяции позиции и увеличения используют вектора, для поворота используются кватернионы, т.к. они очень легко интерполируются (SLERP) в отличии от углов Эйлера, также их очень просто представить в виде матрицы трансформации.</p>
<h3>Как упростить реализацию</h3>
<p>Чтобы упростить отладку работы вертексного шейдера, я добавил симуляцию работы вертексного шейдера на CPU с помощью макроса FSGLOGLNEWAGERENDERER_CPU_BASED_VERTEX_MODS_ENABLED. У производителя видеокарт NVIDIA есть утилита для отладки шейдерного кода Nsight, возможно она тоже может упростить разработку сложных алгоритмов вертексного/пиксельных шейдеров, однако проверить работоспособность мне так и не довелось, хватило симуляции на CPU.</p>
<p>В следующей статье я планирую описать микширование нескольких анимаций, заполнить оставшиеся пробелы.</p>
<h3>Источники</h3>
<p><a href="https://www.youtube.com/watch?v=f3Cr8Yx3GGA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=f3Cr8Yx3GGA</a></p>