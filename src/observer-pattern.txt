Format: Fall24-October10
Language: ru
Title: Паттерн Наблюдатель
Slug: observer-pattern
Categories: techie,tutorials
<p><img loading="lazy" decoding="async" class="alignnone size-full wp-image-2151" src="https://demensdeum.com/blog/wp-content/uploads/2019/08/binacular.jpg" alt="" width="256" height="180" /></p>
<p>Паттерн Наблюдатель (Observer) относится к поведенческим паттернам проектирования.<br />
Паттерн позволяет отправлять изменение состояния объекта подписчикам, с использованием общего интерфейса.<br />
Допустим мы разрабатываем мессенджер для программистов, у нас в приложении есть экран чата. При получении сообщения с текстом “проблема” и “ошибка” или “что-то не так”, нужно красить экран списка ошибок и экран настроек в красный цвет.<br />
Далее я опишу 2 варианта решения задачи, первый простой но крайне сложный в поддержке, и второй гораздо стабильнее в поддержке, но требует включать голову при начальной реализации.</p>
<h3>Общая шина</h3>
<p>Все реализации паттерна содержат отправку сообщений при изменении данных, подписку на сообщения, дальнейшую обработку в методах. Вариант с общей шиной содержит единый объект (обычно используется синглтон) который обеспечивает диспетчеризацию сообщений получателям.<br />
Простота реализации заключается в следующем:</p>
<ol>
<li>Объект отправляет абстрактное сообщение в общую шину</li>
<li>Другой объект подписанный на общую шину, ловит сообщение и решает обработать его или нет.</li>
</ol>
<p>Один из вариантов реализации доступный у Apple (подсистема NSNotificationCenter), добавлен матчинг заголовка сообщения на имя метода, который вызывается у получателя при доставке.<br />
Самый большой минус такого подхода &#8211; при дальнейшем изменении сообщения нужно будет сначала вспомнить, а затем вручную отредактировать все места где оно обрабатывается, отправляется. Налицо случай быстрой первичной реализации, дальнейшей долгой, сложной поддержки, требующей базы знаний для корректной работы.</p>
<h3>Мультикаст делегат</h3>
<p>В данной реализации сделаем финальный класс мультикаст-делегата, на него также как и в случае с общей шиной могут подписываться объекты для получения “сообщений” или “событий”, однако на плечи объектов не возлагается работа по разбору и фильтрации сообщений. Вместо этого классы подписчиков должны имплементировать методы мультикаст делегата, с помощью которых он их нотифицирует.<br />
Реализуется это с помощью использования интерфейсов/протоколов делегата, при изменении общего интерфейса приложение перестанет собираться, в этот момент нужно будет переделать все места обработки данного сообщения, без необходимости держать отдельную базу знаний для запоминания этих мест. <em>Компилятор твой друг.</em><br />
В данном подходе повышается производительность команды, так как отсутствует необходимость писать, хранить документацию, нет необходимости новому разработчику пытаться понять как происходит обработка сообщения, его аргументов, вместо этого происходит работа с удобным и понятным интерфейсом, так реализуется парадигма документирования через код.<br />
Сам мультикаст-делегат основывается на паттерне делегат, о нем я напишу в следующей заметке.</p>
<h3>Источники</h3>
<p><a href="https://refactoring.guru/ru/design-patterns/observer" target="_blank" rel="noopener">https://refactoring.gu/ru/design-patterns/observer</a></p>